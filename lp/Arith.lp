require open eo2lp.Zdiv eo2lp.Q Stdlib.HOL;

symbol If : ğ”¹ â†’ Set â†’ Set â†’ Set;
rule If true $a _  â†ª $a
with If false _ $b â†ª $b;

sequential symbol {|eo::ite|}
  [a b] (p : ğ”¹) : Ï„ (a â¤³ b â¤³ If p a b);
rule {|eo::ite|} true $x _ â†ª $x
with {|eo::ite|} false _ $y â†ª $y;

sequential symbol {|eo::is_neg|}
  [a] : Ï„ (a â¤³ bool);

sequential symbol {|eo::neg|}
  [a] : Ï„ (a â¤³ a);

sequential symbol {|eo::add|}
  [a : Set] : Ï„ (a â¤³ a â¤³ a);

sequential symbol {|eo::zdiv|}
  [a : Set] : Ï„ (a â¤³ a â¤³ a);

sequential symbol {|eo::to_q|}
  [a b : Set] : Ï„ (a â¤³ b);

sequential symbol {|eo::is_eq_type|}
  : Set â†’ Set â†’ ğ”¹;

rule {|eo::is_eq_type|} $x $x â†ª true
with {|eo::is_eq_type|} _ _   â†ª false;

sequential symbol {|eo::requires_type_in|}
  [U : Set] : Set â†’ Set â†’ Ï„ U â†’ Ï„ U;

rule {|eo::requires_type_in|} $T $T $x â†ª $x;

constant symbol Int : Set;
constant symbol Z : â„¤ â†’ Ï„ Int;

rule {|eo::add|} (Z $x) (Z $y) â†ª Z ($x + $y);
rule {|eo::is_neg|} (Z $x) â†ª isZneg $x;
rule {|eo::neg|} (Z $x) â†ª (Z (â€” $x));
rule {|eo::zdiv|} (Z $x) (Z $y) â†ª Z (zdiv $x $y);


sequential symbol log2 : Ï„ (Int â¤³ Int);
rule log2 (Z 1) â†ª (Z 0)
with log2 $x â†ª
  {|eo::add|} (Z 1) (log2 ({|eo::zdiv|} $x (Z 2)));

symbol sgn [T] (x : Ï„ T) â‰”
  {|eo::ite|} ({|eo::is_neg|} x)
    (Z -1)
    ({|eo::ite|} ({|eo::is_neg|} ({|eo::neg|} x))
      (Z 1) (Z 0));


constant symbol Real : Set;
constant symbol Q : â„š â†’ Ï„ Real;

rule {|eo::to_q|} [Real] [Real] (Q $x) â†ª (Q $x)
with {|eo::to_q|} [Int] [Real]  (Z $x) â†ª (Q ($x â«½ 1));

type Q (0 â«½ 1);

symbol mk_zero (T : Set) â‰”
  {|eo::ite|} ({|eo::is_eq_type|} T Int)
    (Z 0)
    ({|eo::requires_type_in|} T Real (Q (0 â«½ 1)));

compute mk_zero Real;
