require open eo-test.Core Stdlib.Set;
constant symbol Bool : Set;
constant symbol true : τ Bool;
constant symbol false : τ Bool;
constant symbol String : Set;
constant symbol Z : Set;
constant symbol Q : Set;
constant symbol {|as|} [T : Set]: τ (T ⤳ eo⋅⋅Type ⤳ T);
constant symbol is_ok [T : Set]: τ (T ⤳ Bool);
constant symbol ite [T : Set]: τ (Bool ⤳ T ⤳ T ⤳ T);
constant symbol eq [U : Set]: τ (U ⤳ U ⤳ Bool);
constant symbol is_eq [T : Set] [S : Set]: τ (T ⤳ S ⤳ Bool);
constant symbol requires [T : Set] [U : Set] [V : Set]: τ (T ⤳ U ⤳ V ⤳ V);
constant symbol hash [T : Set]: τ (T ⤳ Z);
constant symbol typeof [T : Set]: τ (T ⤳ eo⋅⋅Type);
constant symbol nameof [T : Set]: τ (T ⤳ String);
constant symbol var [T : Set]: τ (String ⤳ T ⤳ T);
constant symbol cmp [T : Set] [U : Set]: τ (T ⤳ U ⤳ Bool);
constant symbol is_var [T : Set]: τ (T ⤳ Bool);
constant symbol and : τ (Bool ⤳ Bool ⤳ Bool);
constant symbol or : τ (Bool ⤳ Bool ⤳ Bool);
constant symbol xor : τ (Bool ⤳ Bool ⤳ Bool);
constant symbol not : τ (Bool ⤳ Bool);
constant symbol add [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol mul [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol neg [T : Set]: τ (T ⤳ T);
constant symbol qdiv [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol zdiv [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol zmod [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol is_neg [T : Set]: τ (T ⤳ Bool);
constant symbol gt [T : Set] [U : Set]: τ (T ⤳ U ⤳ Bool);
constant symbol len [T : Set]: τ (T ⤳ Z);
constant symbol concat [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol extract [T : Set]: τ (T ⤳ Z ⤳ Z ⤳ T);
constant symbol find : τ (String ⤳ String ⤳ Z);
constant symbol to_z [T : Set]: τ (T ⤳ Z);
constant symbol to_q [T : Set]: τ (T ⤳ Q);
constant symbol to_bin [T : Set]: τ (Z ⤳ T ⤳ T);
constant symbol to_str [T : Set]: τ (T ⤳ String);
constant symbol nil [U : Set] [T : Set]: τ ((U ⤳ T ⤳ T) ⤳ eo⋅⋅Type ⤳ T);
constant symbol cons [U : Set] [T : Set]: τ ((U ⤳ T ⤳ T) ⤳ U ⤳ T ⤳ T);
constant symbol list_concat [U : Set] [T : Set]: τ ((U ⤳ T ⤳ T) ⤳ T ⤳ T ⤳ T);
constant symbol list_len [F : Set] [T : Set]: τ (F ⤳ T ⤳ Z);
constant symbol list_nth [F : Set] [T : Set]: τ (F ⤳ T ⤳ Z ⤳ T);
constant symbol list_find [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ Z);
constant symbol list_rev [F : Set] [T : Set]: τ (F ⤳ T ⤳ T);
constant symbol list_erase [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol list_erase_all [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol list_setof [F : Set] [T : Set]: τ (F ⤳ T ⤳ T);
constant symbol list_minclude [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ Bool);
constant symbol list_meq [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ Bool);
constant symbol list_diff [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol list_inter [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol list_singleton_elim [F : Set] [T : Set]: τ (F ⤳ T ⤳ T);
constant symbol List : Set;
constant symbol List⋅⋅nil : τ List;
constant symbol List⋅⋅cons [T : Set]: τ (T ⤳ List ⤳ List);
