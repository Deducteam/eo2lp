require open Stdlib.HOL Stdlib.Bool Stdlib.Z eo2lp.Q Stdlib.String;

symbol int â‰” int;
symbol rat â‰” rat;
symbol str â‰” string;

require Stdlib.List as L;

// object-level application.
injective symbol app [a b]
  : Ï„ (a â¤³ b) â†’ Ï„ a â†’ Ï„ b;

symbol List : Set;
symbol Listâ‹…â‹…nil : Ï„ List;
symbol Listâ‹…â‹…cons [a] : Ï„ a â†’ Ï„ List â†’ Ï„ List;

symbol Type : Set;
rule Ï„ Type â†ª Set;

// If t is ground, return true if t is a value,
// and false otherwise. If t is not ground, it does not evaluate.
sequential symbol is_okay
 [t] : Ï„ t â†’ Ï„ bool;

rule Ï„ bool â†ª ğ”¹;
rule Ï„ string â†ª String;


symbol ite [x] : Ï„ (bool â¤³ x â¤³ x â¤³ x);
rule ite true $t1 _  â†ª $t1
with ite false _ $t2 â†ª $t2;

sequential symbol eq
  [x y] : Ï„ (x â¤³ y â¤³ bool);

sequential symbol is_eq
  [x y] : Ï„ (x â¤³ y â¤³ bool);

sequential symbol cond
  [x] : Ï„ (bool â¤³ x â¤³ x);

rule cond true $t â†ª $t;

// ---- eo::requires ----
sequential symbol requires
  [x y z] : Ï„ (x â¤³ y â¤³ z â¤³ z);
rule requires $t1 $t2 $t3
  â†ª cond (is_eq $t1 $t2) $t3;

symbol requires_type_in
  [x] : Set â†’ Set â†’ Ï„ x â†’ Ï„ x;

symbol requires_type_out
  [x] : Ï„ x â†’ Ï„ x â†’ Set â†’ Set;

sequential symbol hash
  [x] : Ï„ x â†’ â„¤;

sequential symbol typeof
  [x] : Ï„ (x â¤³ Type);
//rule typeof [$x] $t â†ª $x;constant

sequential symbol nameof
  [x] : Ï„ x â†’ Ï„ string;

//sequential symbol var
  //(_ : Ï„ string) (t : Ï„ Type) : Ï„ t;

//rule nameof (var $s _) â†ª $s;
//rule typeof (var _ $t) â†ª $t;

sequential symbol cmp
  [x y] : Ï„ (x â¤³ y â¤³ bool);

sequential symbol is_z
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_q
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_bin
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_str
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_bool
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_var
  [x] : Ï„ (x â¤³ bool);


// ---- boolean operators ----
symbol and [x] : Ï„ (x â¤³ x â¤³ x);

rule and true true â†ª true
with and false _ â†ª false
with and _ false â†ª false;

symbol or [x] : Ï„ (x â¤³ x â¤³ x);

rule or false false â†ª false
with or true _ â†ª true
with and _ true â†ª true;

symbol xor [x] : Ï„ (x â¤³ x â¤³ x);

rule xor true false â†ª true
with xor false true â†ª true
with xor false false â†ª false
with xor false false â†ª false;

symbol not [x] : Ï„ (x â¤³ x);

rule not true â†ª false
with not false â†ª true;


// --- arithmetic ---
//rule Ï„ int â†ª â„¤;

symbol neg [x] : Ï„ (x â¤³ x);
rule neg [int] $x â†ª â€” $x;

symbol add [x] : Ï„ (x â¤³ x â¤³ x);
rule add [int] $x $y â†ª $x + $y;

symbol mul [x] : Ï„ (x â¤³ x â¤³ x);
rule mul [int] $x $y â†ª $x * $y;

symbol qdiv [x] : Ï„ (x â¤³ x â¤³ x);
symbol zdiv [x] : Ï„ (x â¤³ x â¤³ x);

symbol zmod [x] : Ï„ (x â¤³ x â¤³ x);

symbol is_neg [x] : Ï„ (x â¤³ bool);
symbol gt [x] : Ï„ (x â¤³ x â¤³ bool);

// --- strings ---
symbol len [x] : Ï„ (x â¤³ int);
symbol concat [x] : Ï„ (x â¤³ x â¤³ bool);
symbol extract [x] : Ï„ (x â¤³ int â¤³ int â¤³ x);
symbol find : Ï„ (string â¤³ string â¤³ int);

// --- conversion ----
symbol to_z [x] : Ï„ (x â¤³ int);
symbol to_q [x] : Ï„ (x â¤³ rat);
symbol to_bin [x] : Ï„ (x â¤³ pos);
symbol to_str [x] : Ï„ (x â¤³ string);

// ---- list ops ----
symbol nil [x y] (f : Ï„ (x â¤³ y â¤³ y))
  (t : Ï„ Type) : Ï„ y;

symbol cons [x y] (f : Ï„ (x â¤³ y â¤³ y))
  (t1 : Ï„ x) (t2 : Ï„ y) : Ï„ y
  â‰” f t1 t2;

symbol list_len [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ int);

symbol list_concat [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y â¤³ y);

symbol list_nth [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ int â¤³ x);

symbol list_find [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ x â¤³ int);

symbol list_rev [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_erase [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_erase_all [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_setof [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_minclude [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y â¤³ bool);

symbol list_meq [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y â¤³ y);

symbol list_diff [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_singleton_elim [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ x);
