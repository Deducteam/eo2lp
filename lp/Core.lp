require open Stdlib.HOL Stdlib.Bool Stdlib.Z eo2lp.Q Stdlib.String;

symbol int â‰” int;
symbol rat â‰” rat;
symbol str â‰” string;

require open Stdlib.List;

// object-level application.
injective symbol app [a b]
  : Ï„ (a â¤³ b) â†’ Ï„ a â†’ Ï„ b;

// --- fold right with nil terminator ---
symbol foldr_nil [a acc]
  : Ï„ (a â¤³ acc â¤³ acc) â†’ Ï„ (list a) â†’ Ï„ acc â†’ Ï„ acc;

rule foldr_nil $f â–¡ $y â†ª $y
with foldr_nil $f ($x â¸¬ $xs) $y
   â†ª $f $x (foldr_nil $f $xs $y);

// --- fold left with nil terminator ---
symbol foldl_nil [a acc]
  : Ï„ (acc â¤³ a â¤³ acc) â†’ Ï„ acc â†’ Ï„ (list a) â†’ Ï„ acc;

rule foldl_nil $f $y â–¡ â†ª $y
with foldl_nil $f $y ($x â¸¬ $xs)
   â†ª foldl_nil $f ($f $y $x) $xs;

// --- fold right. undefined for â–¡! ---
symbol foldr [a]
  : Ï„ (a â¤³ a â¤³ a) â†’ Ï„ (list a) â†’ Ï„ a;
rule foldr $f ($x â¸¬ $xs) â†ª
  foldr_nil $f (belast $x $xs) (last $x $xs);

// --- fold left. undefined for â–¡! ---
symbol foldl [a]
  : Ï„ (a â¤³ a â¤³ a) â†’ Ï„ (list a) â†’ Ï„ a;
rule foldl $f ($x â¸¬ $xs) â†ª
  foldl_nil $f (last $x $xs) (belast $x $xs);

(a : Set) inductive CONST_ATTR : TYPE â‰”
  | RightAssocNil : Ï„ a â†’ CONST_ATTR a
  | LeftAssocNil : Ï„ a â†’ CONST_ATTR a
  | RightAssocNilNSN : Ï„ a â†’ CONST_ATTR a
  | LeftAssocNilNSN : Ï„ a â†’ CONST_ATTR a
  | LeftAssoc : CONST_ATTR a
  | RightAssoc : CONST_ATTR a
  | ArgList : Ï„ a â†’ CONST_ATTR a
  | Chainable : Ï„ a â†’ CONST_ATTR a
  | Pairwise : Ï„ a â†’ CONST_ATTR a
  | Binder : Ï„ a â†’ CONST_ATTR a;

// -- generic fold. dispatch on const attribute ---
// doesn't work because of types.
// so we do desugaring in OCaml still.
symbol fold [a b c d]
  : Ï„ (a â¤³ b â¤³ c) â†’ Ï„ (list d) â†’ CONST_ATTR c â†’ Ï„ c;
// it would work if we have a 'meta' file that just operates
// on eos. then, we use these meta rules to rewrite things.



rule fold $f $xs (RightAssocNil $t) â†ª foldr_nil $f $xs $t;
rule fold [$a] [$b] $f $xs (LeftAssocNil $t) â†ª foldl_nil $f $t $xs;

rule fold $f $xs LeftAssoc â†ª foldl $f $xs;

symbol ite [a] : ğ”¹ â†’ Ï„ a â†’ Ï„ a â†’ Ï„ a;

symbol Type : Set;
rule Ï„ Type â†ª Set;

symbol List : Set;
symbol Listâ‹…â‹…nil : Ï„ List;
symbol Listâ‹…â‹…cons [a] : Ï„ a â†’ Ï„ List â†’ Ï„ List;


// If t is ground, return true if t is a value,
// and false otherwise. If t is not ground, it does not evaluate.
sequential symbol is_okay
 [t] : Ï„ t â†’ Ï„ bool;

rule Ï„ bool â†ª ğ”¹;
rule Ï„ string â†ª String;


symbol ite [x] : Ï„ (bool â¤³ x â¤³ x â¤³ x);
rule ite true $t1 _  â†ª $t1
with ite false _ $t2 â†ª $t2;

sequential symbol eq
  [x y] : Ï„ (x â¤³ y â¤³ bool);

sequential symbol is_eq
  [x y] : Ï„ (x â¤³ y â¤³ bool);

sequential symbol cond
  [x] : Ï„ (bool â¤³ x â¤³ x);

rule cond true $t â†ª $t;

// ---- eo::requires ----
sequential symbol requires
  [x y z] : Ï„ (x â¤³ y â¤³ z â¤³ z);
rule requires $t1 $t2 $t3
  â†ª cond (is_eq $t1 $t2) $t3;

symbol requires_type_in
  [x] : Set â†’ Set â†’ Ï„ x â†’ Ï„ x;

symbol requires_type_out
  [x] : Ï„ x â†’ Ï„ x â†’ Set â†’ Set;

sequential symbol hash
  [x] : Ï„ x â†’ â„¤;

sequential symbol typeof
  [x] : Ï„ (x â¤³ Type);
//rule typeof [$x] $t â†ª $x;constant

sequential symbol nameof
  [x] : Ï„ x â†’ Ï„ string;

//sequential symbol var
  //(_ : Ï„ string) (t : Ï„ Type) : Ï„ t;

//rule nameof (var $s _) â†ª $s;
//rule typeof (var _ $t) â†ª $t;

sequential symbol cmp
  [x y] : Ï„ (x â¤³ y â¤³ bool);

sequential symbol is_z
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_q
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_bin
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_str
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_bool
  [x] : Ï„ (x â¤³ bool);

sequential symbol is_var
  [x] : Ï„ (x â¤³ bool);


// ---- boolean operators ----
symbol and [x] : Ï„ (x â¤³ x â¤³ x);

rule and true true â†ª true
with and false _ â†ª false
with and _ false â†ª false;

symbol or [x] : Ï„ (x â¤³ x â¤³ x);

rule or false false â†ª false
with or true _ â†ª true
with and _ true â†ª true;

symbol xor [x] : Ï„ (x â¤³ x â¤³ x);

rule xor true false â†ª true
with xor false true â†ª true
with xor false false â†ª false
with xor false false â†ª false;

symbol not [x] : Ï„ (x â¤³ x);

rule not true â†ª false
with not false â†ª true;


// --- arithmetic ---
//rule Ï„ int â†ª â„¤;

symbol neg [x] : Ï„ (x â¤³ x);
rule neg [int] $x â†ª â€” $x;

symbol add [x] : Ï„ (x â¤³ x â¤³ x);
rule add [int] $x $y â†ª $x + $y;

symbol mul [x] : Ï„ (x â¤³ x â¤³ x);
rule mul [int] $x $y â†ª $x * $y;

symbol qdiv [x] : Ï„ (x â¤³ x â¤³ x);
symbol zdiv [x] : Ï„ (x â¤³ x â¤³ x);

symbol zmod [x] : Ï„ (x â¤³ x â¤³ x);

symbol is_neg [x] : Ï„ (x â¤³ bool);
symbol gt [x] : Ï„ (x â¤³ x â¤³ bool);

// --- strings ---
symbol len [x] : Ï„ (x â¤³ int);
symbol concat [x] : Ï„ (x â¤³ x â¤³ bool);
symbol extract [x] : Ï„ (x â¤³ int â¤³ int â¤³ x);
symbol find : Ï„ (string â¤³ string â¤³ int);

// --- conversion ----
symbol to_z [x] : Ï„ (x â¤³ int);
symbol to_q [x] : Ï„ (x â¤³ rat);
symbol to_bin [x] : Ï„ (x â¤³ pos);
symbol to_str [x] : Ï„ (x â¤³ string);

// ---- list ops ----
symbol nil [x y] (f : Ï„ (x â¤³ y â¤³ y))
  (t : Ï„ Type) : Ï„ y;

symbol cons [x y] (f : Ï„ (x â¤³ y â¤³ y))
  (t1 : Ï„ x) (t2 : Ï„ y) : Ï„ y
  â‰” f t1 t2;

symbol list_len [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ int);

symbol list_concat [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y â¤³ y);

symbol list_nth [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ int â¤³ x);

symbol list_find [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ x â¤³ int);

symbol list_rev [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_erase [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_erase_all [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_setof [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_minclude [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y â¤³ bool);

symbol list_meq [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y â¤³ y);

symbol list_diff [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ y);

symbol list_singleton_elim [x y] (f : Ï„ (x â¤³ y â¤³ y))
  : Ï„ (y â¤³ x);
