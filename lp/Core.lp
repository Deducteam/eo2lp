require open eo2lp.Meta Stdlib.Set;
constant symbol Bool : Set;
constant symbol true : τ Bool;
constant symbol false : τ Bool;
constant symbol eo⋅⋅String : Set;
constant symbol eo⋅⋅Z : Set;
constant symbol eo⋅⋅Q : Set;
constant symbol eo⋅⋅is_ok [T : Set]: τ (T ⤳ Bool);
constant symbol eo⋅⋅ite [T : Set]: τ (Bool ⤳ T ⤳ T ⤳ T);
constant symbol eo⋅⋅eq [U : Set]: τ (U ⤳ U ⤳ Bool);
constant symbol eo⋅⋅is_eq [T : Set] [S : Set]: τ (T ⤳ S ⤳ Bool);
constant symbol eo⋅⋅requires [T : Set] [U : Set] [V : Set]: τ (T ⤳ U ⤳ V ⤳ V);
constant symbol eo⋅⋅hash [T : Set]: τ (T ⤳ eo⋅⋅Z);
constant symbol eo⋅⋅typeof [T : Set]: τ (T ⤳ eo⋅⋅Type);
constant symbol eo⋅⋅nameof [T : Set]: τ (T ⤳ eo⋅⋅String);
constant symbol eo⋅⋅var [T : Set]: τ (eo⋅⋅String ⤳ T ⤳ T);
constant symbol eo⋅⋅cmp [T : Set] [U : Set]: τ (T ⤳ U ⤳ Bool);
constant symbol eo⋅⋅is_var [T : Set]: τ (T ⤳ Bool);
constant symbol eo⋅⋅and : τ (Bool ⤳ Bool ⤳ Bool);
constant symbol eo⋅⋅or : τ (Bool ⤳ Bool ⤳ Bool);
constant symbol eo⋅⋅xor : τ (Bool ⤳ Bool ⤳ Bool);
constant symbol eo⋅⋅not : τ (Bool ⤳ Bool);
constant symbol eo⋅⋅add [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol eo⋅⋅mul [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol eo⋅⋅neg [T : Set]: τ (T ⤳ T);
constant symbol eo⋅⋅qdiv [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol eo⋅⋅zdiv [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol eo⋅⋅zmod [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol eo⋅⋅is_neg [T : Set]: τ (T ⤳ Bool);
constant symbol eo⋅⋅gt [T : Set] [U : Set]: τ (T ⤳ U ⤳ Bool);
constant symbol eo⋅⋅len [T : Set]: τ (T ⤳ eo⋅⋅Z);
constant symbol eo⋅⋅concat [T : Set]: τ (T ⤳ T ⤳ T);
constant symbol eo⋅⋅extract [T : Set]: τ (T ⤳ eo⋅⋅Z ⤳ eo⋅⋅Z ⤳ T);
constant symbol eo⋅⋅find : τ (eo⋅⋅String ⤳ eo⋅⋅String ⤳ eo⋅⋅Z);
constant symbol eo⋅⋅to_z [T : Set]: τ (T ⤳ eo⋅⋅Z);
constant symbol eo⋅⋅to_q [T : Set]: τ (T ⤳ eo⋅⋅Q);
constant symbol eo⋅⋅to_bin [T : Set]: τ (eo⋅⋅Z ⤳ T ⤳ T);
constant symbol eo⋅⋅to_str [T : Set]: τ (T ⤳ eo⋅⋅String);
constant symbol eo⋅⋅nil [U : Set] [T : Set]: τ ((U ⤳ T ⤳ T) ⤳ eo⋅⋅Type ⤳ T);
constant symbol eo⋅⋅cons [U : Set] [T : Set]: τ ((U ⤳ T ⤳ T) ⤳ U ⤳ T ⤳ T);
constant symbol eo⋅⋅list_concat [U : Set] [T : Set]: τ ((U ⤳ T ⤳ T) ⤳ T ⤳ T ⤳ T);
constant symbol eo⋅⋅list_len [F : Set] [T : Set]: τ (F ⤳ T ⤳ eo⋅⋅Z);
constant symbol eo⋅⋅list_nth [F : Set] [T : Set]: τ (F ⤳ T ⤳ eo⋅⋅Z ⤳ T);
constant symbol eo⋅⋅list_find [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ eo⋅⋅Z);
constant symbol eo⋅⋅list_rev [F : Set] [T : Set]: τ (F ⤳ T ⤳ T);
constant symbol eo⋅⋅list_erase [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol eo⋅⋅list_erase_all [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol eo⋅⋅list_setof [F : Set] [T : Set]: τ (F ⤳ T ⤳ T);
constant symbol eo⋅⋅list_minclude [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ Bool);
constant symbol eo⋅⋅list_meq [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ Bool);
constant symbol eo⋅⋅list_diff [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol eo⋅⋅list_eo⋅⋅Zer [F : Set] [T : Set]: τ (F ⤳ T ⤳ T ⤳ T);
constant symbol eo⋅⋅list_singleton_elim [F : Set] [T : Set]: τ (F ⤳ T ⤳ T);
constant symbol eo⋅⋅List : Set;
constant symbol eo⋅⋅List⋅⋅nil : τ eo⋅⋅List;
constant symbol eo⋅⋅List⋅⋅cons [T : Set]: τ (T ⤳ eo⋅⋅List ⤳ eo⋅⋅List);
