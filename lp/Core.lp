require open Stdlib.HOL Stdlib.Bool Stdlib.Z Stdlib.String;
require open Stdlib.List;
require open eo2lp.Q;

// object-level application.
constant symbol â–« [a b]
  : Ï„ (a â¤³ b) â†’ Ï„ a â†’ Ï„ b;
notation â–« infix left 5;

injective symbol eo : Set â†’ TYPE;

symbol Type : Set;
rule eo Type â†ª Set;


symbol halt [a] : eo a;
//If t is ground, this returns true if t is a value, and false otherwise. If t is not ground, it does not evaluate.
sequential symbol is_okay
 [t] : eo t â†’ eo bool;

constant symbol true : eo bool;
constant symbol false : eo bool;
rule eo bool â†ª ğ”¹;

rule eo string â†ª String;


rule eo ($x â¤³ $y) â†ª eo $x â†’ eo $y;

symbol ifset : ğ”¹ â†’ Set â†’ Set â†’ Set;
rule ifset true $x _ â†ª $x
with ifset false _ $y â†ª $y;

sequential symbol ite
  [x y ] (p : eo bool) : eo (x â¤³ y â¤³ ifset p x y);

rule ite  true $t1 _ â†ª $t1
with ite false _ $t2 â†ª $t2;

sequential symbol eq
  [x y] : eo (x â¤³ y â¤³ bool);

sequential symbol is_eq
  [x y] : eo (x â¤³ y â¤³ bool);

sequential symbol cond
  [x] : eo (bool â¤³ x â¤³ x);
rule cond true $t â†ª $t;

sequential symbol requires
  [x y z] : eo (x â¤³ y â¤³ z â¤³ z);
rule requires $t1 $t2 $t3
  â†ª cond (is_eq $t1 $t2) $t3;

sequential symbol hash
  [x] : eo x â†’ â„¤;

sequential symbol typeof
  [x] : eo x â†’ eo Type;
rule typeof [$x] $t â†ª $x;

sequential symbol nameof
  [x] : eo x â†’ eo string;

sequential symbol var
  (_ : eo string) (t : eo Type) : eo t;

rule nameof (var $s _) â†ª $s;
rule typeof (var _ $t) â†ª $t;

sequential symbol cmp
  [x y] : eo (x â¤³ y â¤³ bool);

sequential symbol is_z
  [x] : eo (x â¤³ bool);

sequential symbol is_q
  [x] : eo (x â¤³ bool);

sequential symbol is_bin
  [x] : eo (x â¤³ bool);

sequential symbol is_str
  [x] : eo (x â¤³ bool);

sequential symbol is_bool
  [x] : eo (x â¤³ bool);

sequential symbol is_var
  [x] : eo (x â¤³ bool);


// ---- boolean operators ----
symbol and [x] : eo (x â¤³ x â¤³ x);

rule and true true â†ª true
with and false _ â†ª false
with and _ false â†ª false;

symbol or [x] : eo (x â¤³ x â¤³ x);

rule or false false â†ª false
with or true _ â†ª true
with and _ true â†ª true;

symbol xor [x] : eo (x â¤³ x â¤³ x);

rule xor true false â†ª true
with xor false true â†ª true
with xor false false â†ª false
with xor false false â†ª false;

symbol not [x] : eo (x â¤³ x);

rule not true â†ª false
with not false â†ª true;


// --- arithmetic ---
rule eo int â†ª â„¤;

symbol neg [x] : eo (x â¤³ x);
rule neg [int] $x â†ª â€” $x;

symbol add [x] : eo (x â¤³ x â¤³ x);
rule add [int] $x $y â†ª $x + $y;

symbol mul [x] : eo (x â¤³ x â¤³ x);
rule mul [int] $x $y â†ª $x * $y;

symbol qdiv [x] : eo (x â¤³ x â¤³ x);
symbol zdiv [x] : eo (x â¤³ x â¤³ x);

symbol zmod [x] : eo (x â¤³ x â¤³ x);

symbol is_neg [x] : eo (x â¤³ bool);
symbol gt [x] : eo (x â¤³ x â¤³ bool);

// --- strings ---
symbol len [x] : eo (x â¤³ int);
symbol concat [x] : eo (x â¤³ x â¤³ bool);
symbol extract [x] : eo (x â¤³ int â¤³ int â¤³ x);
symbol find : eo (string â¤³ string â¤³ int);

// --- conversion ----
symbol to_z [x] : eo (x â¤³ int);
symbol to_q [x] : eo (x â¤³ rat);
symbol to_bin [x] : eo (x â¤³ pos);
symbol to_str [x] : eo (x â¤³ string);

// ---- list ops ----
symbol nil [x y] (f : eo (x â¤³ y â¤³ y))
  (t : eo Type) : eo t;

symbol cons [x y] (f : eo (x â¤³ y â¤³ y))
  (t1 : eo x) (t2 : eo y) : eo y
  â‰” f t1 t2;

symbol list_len [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ int);

symbol list_concat [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y â¤³ y);

symbol list_nth [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ int â¤³ x);

symbol list_find [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ x â¤³ int);

symbol list_rev [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y);

symbol list_erase [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y);

symbol list_erase_all [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y);

symbol list_setof [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y);

symbol list_minclude [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y â¤³ bool);

symbol list_meq [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y â¤³ y);

symbol list_diff [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ y);

symbol list_singleton_elim [x y] (f : eo (x â¤³ y â¤³ y))
  : eo (y â¤³ x);
