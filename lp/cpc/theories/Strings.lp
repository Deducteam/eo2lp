require open cpc.Core Stdlib.Set cpc.theories.Builtin cpc.theories.Arith;
constant symbol Seq : τ (eo⋅⋅Type ⤳ eo⋅⋅Type);
constant symbol Char : Set;
symbol String ≔ Seq Char;
constant symbol RegLan : Set;
constant symbol seq⋅empty [T : Set]: τ (Seq T);
sequential symbol !seq_empty [T : Set]: τ ((eo⋅⋅quote T) ⤳ T);
rule !seq_empty String ↪ ""
with !seq_empty ($T) ↪ {|as|} seq⋅empty ($T);
constant symbol str⋅len [T : Set]: τ ((Seq T) ⤳ Int);
constant symbol str⋅++ [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Seq T);
constant symbol str⋅substr [T : Set]: τ ((Seq T) ⤳ Int ⤳ Int ⤳ Seq T);
constant symbol str⋅contains [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Bool);
constant symbol str⋅replace [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ (Seq T) ⤳ Seq T);
constant symbol str⋅indexof [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Int ⤳ Int);
constant symbol str⋅at [T : Set]: τ ((Seq T) ⤳ Int ⤳ Seq T);
constant symbol str⋅prefixof [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Bool);
constant symbol str⋅suffixof [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Bool);
constant symbol str⋅rev [T : Set]: τ ((Seq T) ⤳ Seq T);
constant symbol str⋅update [T : Set]: τ ((Seq T) ⤳ Int ⤳ (Seq T) ⤳ Seq T);
constant symbol str⋅to_lower : τ (String ⤳ String);
constant symbol str⋅to_upper : τ (String ⤳ String);
constant symbol str⋅to_code : τ (String ⤳ Int);
constant symbol str⋅from_code : τ (Int ⤳ String);
constant symbol str⋅is_digit : τ (String ⤳ Bool);
constant symbol str⋅to_int : τ (String ⤳ Int);
constant symbol str⋅from_int : τ (Int ⤳ String);
constant symbol str⋅< : τ (String ⤳ String ⤳ Bool);
constant symbol str⋅<= : τ (String ⤳ String ⤳ Bool);
constant symbol str⋅replace_all [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ (Seq T) ⤳ Seq T);
constant symbol str⋅replace_re : τ (String ⤳ RegLan ⤳ String ⤳ String);
constant symbol str⋅replace_re_all : τ (String ⤳ RegLan ⤳ String ⤳ String);
constant symbol str⋅indexof_re : τ (String ⤳ RegLan ⤳ Int ⤳ Int);
constant symbol re⋅allchar : τ RegLan;
constant symbol re⋅none : τ RegLan;
constant symbol re⋅all : τ RegLan;
constant symbol str⋅to_re : τ (String ⤳ RegLan);
symbol {|@re.empty|} ≔ str⋅to_re ("");
constant symbol re⋅* : τ (RegLan ⤳ RegLan);
constant symbol re⋅+ : τ (RegLan ⤳ RegLan);
constant symbol re⋅^ : τ (Int ⤳ RegLan ⤳ RegLan);
constant symbol re⋅opt : τ (RegLan ⤳ RegLan);
constant symbol re⋅comp : τ (RegLan ⤳ RegLan);
constant symbol re⋅range : τ (String ⤳ String ⤳ RegLan);
constant symbol re⋅++ : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re⋅inter : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re⋅union : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re⋅diff : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re⋅loop : τ (Int ⤳ Int ⤳ RegLan ⤳ RegLan);
constant symbol str⋅in_re : τ (String ⤳ RegLan ⤳ Bool);
constant symbol seq⋅unit [T : Set]: τ (T ⤳ Seq T);
constant symbol seq⋅nth [T : Set]: τ ((Seq T) ⤳ Int ⤳ T);
symbol seq⋅len ≔ str⋅len;
symbol seq⋅++ ≔ str⋅++;
symbol seq⋅extract ≔ str⋅substr;
symbol seq⋅contains ≔ str⋅contains;
symbol seq⋅replace ≔ str⋅replace;
symbol seq⋅replace_all ≔ str⋅replace_all;
symbol seq⋅indexof ≔ str⋅indexof;
symbol seq⋅prefixof ≔ str⋅prefixof;
symbol seq⋅suffixof ≔ str⋅suffixof;
symbol seq⋅rev ≔ str⋅rev;
symbol seq⋅update ≔ str⋅update;
symbol seq⋅at ≔ str⋅at;
constant symbol {|@re_unfold_pos_component|} (s : τ String) (r : τ RegLan) (n : τ Int): τ String;
constant symbol {|@strings_deq_diff|} [T : Set] (s : τ (Seq T)) (t : τ (Seq T)): τ Int;
constant symbol {|@strings_stoi_result|} (s : τ String): τ (Int ⤳ Int);
constant symbol {|@strings_stoi_non_digit|} (s : τ String): τ Int;
constant symbol {|@strings_itos_result|} (n : τ Int): τ (Int ⤳ Int);
constant symbol {|@strings_num_occur|} [T : Set] (s : τ (Seq T)) (t : τ (Seq T)): τ Int;
constant symbol {|@strings_num_occur_re|} (e : τ String) (b : τ RegLan): τ Int;
constant symbol {|@strings_occur_index|} [T : Set] (s : τ (Seq T)) (t : τ (Seq T)): τ (Int ⤳ Int);
constant symbol {|@strings_occur_index_re|} (s : τ String) (r : τ RegLan): τ (Int ⤳ Int);
constant symbol {|@strings_replace_all_result|} [T : Set] (t : τ (Seq T)): τ (Int ⤳ Seq T);
constant symbol {|@witness_string_length|} (T : Set): τ (Int ⤳ Int ⤳ T);
