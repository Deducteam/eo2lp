require open
  Stdlib.Set
  Stdlib.HOL
  Stdlib.List
  Stdlib.String
  Stdlib.Z
  Stdlib.Bool;

symbol â„š : TYPE;

// the set of all Eunoia types.
symbol Type : Set;
rule Ï„ Type â†ª Set;

// dependent arrow type for quoting
symbol â¤³d (T : Ï„ Type) : Ï„ (T â¤³ Type) â†’ Ï„ Type;
notation â¤³d infix right 5;
rule Ï„ ($T â¤³d $F) â†ª (Î  x : Ï„ $T, Ï„ ($F x));

// higher-order application.
symbol â‹… [a b] : Ï„ (a â¤³ b) â†’ Ï„ a â†’ Ï„ b;
notation â‹… infix left 5;

// inlined typechecking.
symbol _as (a : Set) (x : Ï„ a) : Ï„ a;
rule _as _ $x â†ª $x;

// Core types - use Stdlib types where possible
symbol Bool : Set;
rule Ï„ Bool â†ª ğ”¹;
symbol Str : Set;
rule Ï„ Str â†ª Stdlib.String.String;
symbol Z : Set;
rule Ï„ Z â†ª â„¤;
symbol Q : Set;
rule Ï„ Q â†ª â„š;
symbol mkrat : â„¤ â†’ â„¤ â†’ â„š;

symbol ?? : ğ”¹ â†’ Set â†’ Set â†’ Set;
rule ?? _ $x $x â†ª $x
with ?? true $x _ â†ª $x
with ?? false _ $y â†ª $y;

// just !arith_typeunion but for the eo.add, etc.
symbol âŠ : Set â†’ Set â†’ Set; notation âŠ infix 5;
rule Z âŠ Z â†ª Z
with Q âŠ Q â†ª Q
with Q âŠ Z â†ª Q
with Z âŠ Q â†ª Q;

// Eunoia builtins
sequential symbol is_ok [T : Set]: Ï„ (T â¤³ Bool);
sequential symbol ite [U T : Set] (b : Ï„ Bool) : Ï„ (U â¤³ T â¤³ (?? b U T));
sequential symbol eq [T : Set] [S : Set] : Ï„ (T â¤³ S â¤³ Bool);
sequential symbol is_eq [T : Set] [S : Set]: Ï„ (T â¤³ S â¤³ Bool);
sequential symbol requires [T : Set] [U : Set] [V : Set]: Ï„ (T â¤³ U â¤³ V â¤³ V);
sequential symbol hash [T : Set]: Ï„ (T â¤³ Z);
sequential symbol typeof [T : Set]: Ï„ (T â¤³ Type);
sequential symbol nameof [T : Set]: Ï„ (T â¤³ Str);
sequential symbol var [T : Set]: Ï„ (Str â¤³ T â¤³ T);
sequential symbol cmp [T : Set] [U : Set]: Ï„ (T â¤³ U â¤³ Bool);
sequential symbol is_var [T : Set]: Ï„ (T â¤³ Bool);
sequential symbol is_z [T : Set]: Ï„ (T â¤³ Bool);
sequential symbol and : Ï„ (Bool â¤³ Bool â¤³ Bool);
sequential symbol or : Ï„ (Bool â¤³ Bool â¤³ Bool);
sequential symbol xor : Ï„ (Bool â¤³ Bool â¤³ Bool);
sequential symbol not : Ï„ (Bool â¤³ Bool);
sequential symbol add [T1 : Set] [T2 : Set] : Ï„ (T1 â¤³ T2 â¤³ (T1 âŠ T2));
sequential symbol mul [T1 : Set] [T2 : Set] : Ï„ (T1 â¤³ T2 â¤³ (T1 âŠ T2));
sequential symbol neg [T : Set]: Ï„ (T â¤³ T);
sequential symbol qdiv [T : Set]: Ï„ (T â¤³ T â¤³ T);
sequential symbol zdiv [T : Set]: Ï„ (T â¤³ T â¤³ T);
sequential symbol zmod [T : Set]: Ï„ (T â¤³ T â¤³ T);
sequential symbol is_neg [T : Set]: Ï„ (T â¤³ Bool);
sequential symbol gt [T : Set] [U : Set]: Ï„ (T â¤³ U â¤³ Bool);
sequential symbol len [T : Set]: Ï„ (T â¤³ Z);
sequential symbol concat [T : Set]: Ï„ (T â¤³ T â¤³ T);
sequential symbol extract [T : Set]: Ï„ (T â¤³ Z â¤³ Z â¤³ T);
sequential symbol find : Ï„ (Str â¤³ Str â¤³ Z);
sequential symbol to_z [T : Set]: Ï„ (T â¤³ Z);
sequential symbol to_q [T : Set]: Ï„ (T â¤³ Q);
sequential symbol to_bin [T : Set]: Ï„ (Z â¤³ T â¤³ T);
sequential symbol to_str [T : Set]: Ï„ (T â¤³ Str);
sequential symbol quote [T : Set]: Ï„ (T â¤³ T);
sequential symbol nil [U : Set] [T : Set]: Ï„ ((U â¤³ T â¤³ T) â¤³ Type â¤³ T);
sequential symbol cons [U : Set] [T : Set]: Ï„ ((U â¤³ T â¤³ T) â¤³ U â¤³ T â¤³ T);
sequential symbol list_concat [U : Set] [T : Set]: Ï„ ((U â¤³ T â¤³ T) â¤³ T â¤³ T â¤³ T);
sequential symbol list_len [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ Z);
sequential symbol list_nth [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ Z â¤³ T);
sequential symbol list_find [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ Z);
sequential symbol list_rev [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T);
sequential symbol list_erase [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ T);
sequential symbol list_erase_all [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ T);
sequential symbol list_setof [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T);
sequential symbol list_minclude [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ Bool);
sequential symbol list_meq [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ Bool);
sequential symbol list_diff [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ T);
sequential symbol list_inter [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T â¤³ T);
sequential symbol list_singleton_elim [F : Set] [T : Set]: Ï„ (F â¤³ T â¤³ T);

// eo::List, eo::List::cons, eo::List::ni
symbol List : Ï„ Type;
sequential symbol List__nil : Ï„ List; symbol âˆ â‰” List__nil;
sequential symbol List__cons [T : Set]: Ï„ (T â¤³ List â¤³ List);
