require open Stdlib.HOL Stdlib.Bool;

require Stdlib.List as L;
require Stdlib.String as Str;
require Stdlib.Pos as Bin;
require open Stdlib.Comp;
require Stdlib.Z as Int;

require prelude.Q as Rat;

// the set of all Eunoia types.
symbol Type : Set;
rule Ï„ Type â†ª Set;

// dependent arrow type for quoting
symbol â¤³d (T : Ï„ Type) : Ï„ (T â¤³ Type) â†’ Ï„ Type;
notation â¤³d infix right 5;
rule Ï„ ($T â¤³d $F) â†ª (Î  x : Ï„ $T, Ï„ ($F x));

// higher-order application.
symbol â‹… [a b] : Ï„ (a â¤³ b) â†’ Ï„ a â†’ Ï„ b;
notation â‹… infix left 5;

// inlined typechecking.
symbol _as (a : Set) (x : Ï„ a) : Ï„ a;
rule _as _ $x â†ª $x;

// Core types - use Stdlib types where possible
symbol Bool : Set;
rule Ï„ Bool â†ª ğ”¹;

symbol <str> : Set;
rule Ï„ <str> â†ª Str.String;

symbol <int> : Set;
rule Ï„ <int> â†ª Int.â„¤;

symbol <rat> : Set;
rule Ï„ <rat> â†ª Rat.â„š;

// just !arith_typeunion but for the eo.add, etc.
// Note: we need rules for both <int>/<rat> (Prelude types) and any aliases defined
// in theory files. Since we can't predict all aliases, theories that define
// type aliases like `Int â‰” <int>` should also add corresponding âŠ rules.
symbol âŠ : Set â†’ Set â†’ Set; notation âŠ infix 5;
rule <int> âŠ <int> â†ª <int>
with <rat> âŠ <rat> â†ª <rat>
with <rat> âŠ <int> â†ª <rat>
with <int> âŠ <rat> â†ª <rat>;

symbol âŠ¥ : Set;

symbol ?? : ğ”¹ â†’ Set â†’ Set â†’ Set;
rule ?? _ $x $x â†ª $x
with ?? true $x _ â†ª $x
with ?? false _ $y â†ª $y;



// Eunoia builtins
// `(is_ok t)`: If `t` is ground, this returns true if `t` is a value, and
// false otherwise. If `t` is not ground, it does not evaluate.
sequential symbol is_ok [T : Set]: Ï„ (T â¤³ Bool);

// `(ite t1 t2 t3)`: Returns `t2` if `t1` is `true`, `t3` if `t1` is `false`,
// and is not evaluated otherwise. Note that the branches of this term are
// only evaluated if they are the return term.
sequential symbol ite [U T : Set] (b : Ï„ Bool) : Ï„ (U â¤³ T â¤³ (?? b U T));
rule ite true $x _ â†ª $x
with ite false _ $y â†ª $y;

// `(eq t1 t2)`: If `t1` and `t2` are ground values, this returns `true` if
// `t1` is (syntactically) equal to `t2` and `false` otherwise. If either
// `t1` or `t2` is non-ground, it does not evaluate.
sequential symbol eq [T : Set] [S : Set] : Ï„ (T â¤³ S â¤³ Bool);
rule eq $x $x â†ª true
with eq _ _ â†ª false;

// `(requires t1 t2 t3)`: Returns `t3` if `(is_eq t1 t2)` evaluates to
// `true`, and is not evaluated otherwise. In the case this operator
// evaluates, it may be the case that `t3` is non-ground.
sequential symbol requires [T U V]
  (x : Ï„ T) (y : Ï„ U) (z : Ï„ V) : Ï„ V;
rule requires $x $x $z â†ª $z;

// `(is_eq t1 t2)`: Equivalent to `(ite (and (is_ok t) (is_ok s)) (eq s t) false)`.
sequential symbol is_eq [T1 T2]: Ï„ (T1 â¤³ T2 â¤³ Bool);
// `(hash t1)`: If `t1` is a value, this returns a numeral that is unique
// to `t1`.
sequential symbol hash [T : Set]: Ï„ (T â¤³ <int>);

// ---- types, variables, names. ----
// `(typeof t1)`: If `t1` is a value, this returns the type of `t1` if its
// type is ground.
sequential symbol typeof [T : Set]: Ï„ (T â¤³ Type);
rule typeof [$T] _ â†ª $T;

// `(var t1 t2)`: If `t1` is a string value and `t2` is a ground type, this
// returns the variable whose name is `t1` and whose type is `t2`.
sequential symbol var [T : Set]: Ï„ (<str> â¤³ T â¤³ T);

// `(nameof t1)`: If `t1` is a ground constant or variable, this returns
// the name of `t1`, i.e. the string corresponding to the symbol it was
// declared with.
sequential symbol nameof [T : Set]: Ï„ (T â¤³ <str>);
rule nameof (var $s _) â†ª $s;

// `(cmp t1 t2)`: Equivalent to `(is_neg (add (neg (hash t1)) (hash t2)))`.
// Note that this method corresponds to an arbitrary total order on terms.
sequential symbol cmp [T : Set] [U : Set]: Ï„ (T â¤³ U â¤³ Bool);

// `(is_var t)`: Equivalent to `(is_eq (var (nameof t) (typeof t)) t)`.
sequential symbol is_var [T : Set]: Ï„ (T â¤³ Bool);
rule is_var (var $s _) â†ª true
with is_var _          â†ª false;

// `(is_z t)`: Equivalent to `(is_eq (to_z t) t)`.
sequential symbol is_z [T : Set]: Ï„ (T â¤³ Bool);
rule is_z [<int>] _ â†ª true
with is_z _ â†ª false;

// ---- conversion operators. ----
// `(to_z t1)`: Converts `t1` to an integer.
// - If `t1` is a numeral value, return `t1`.
// - If `t1` is a rational value, return the numeral value corresponding to the floor of `t1`.
// - If `t1` is a binary value, this returns the numeral value corresponding to `t1`.
// - If `t1` is a string value of length one, this returns the code point of its character.
sequential symbol to_z [T : Set]: Ï„ (T â¤³ <int>);

// `(to_q t1)`: Converts `t1` to a rational.
// - If `t1` is a rational value, return `t1`.
// - If `t1` is a numeral value, this returns the (integral) rational value that is equivalent to `t1`.
sequential symbol to_q [T : Set]: Ï„ (T â¤³ <rat>);

// `(to_bin t1 t2)`: Converts `t2` to a binary value of bitwidth `t1`.
// - If `t1` is a 32-bit numeral value and `t2` is a binary value, this
//   returns a binary value whose value is `t2` and whose bitwidth is `t1`.
// - If `t1` is a 32-bit numeral value and `t2` is a non-negative numeral
//   value, return the binary value whose value is `t2` (modulo `2^t1`) and
//   whose bitwidth is `t1`.
sequential symbol to_bin [T : Set]: Ï„ (<int> â¤³ T â¤³ T);

// `(to_str t1)`: Converts `t1` to a string.
// - If `t1` is a string value, return `t1`.
// - If `t1` is a numeral value specifying a code point from Unicode planes
//   `0-2` (i.e. a numeral between `0` and `196607`), return the string of
//   length one whose character has code point `t1`.
// - If `t1` is a rational or binary value, return the string value
//   corresponding to the result of printing `t1`.
// - If `t1` is a hexadecimal value, return the string value corresponding
//   to the result of printing `t1`. This will use lowercase letters for
//   digits greater than `9`.
// - If `t1` is a decimal value, return the string value corresponding to
//   the result of printing `t1` as a rational.
sequential symbol to_str [T : Set]: Ï„ (T â¤³ <str>);


// --- logical operators. ---
sequential symbol and : Ï„ (Bool â¤³ Bool â¤³ Bool);
// boolean and conjunction.
rule and true true â†ª true
with and true false â†ª false
with and false true â†ª false
with and false false â†ª false;

// --- eo::or ---
sequential symbol or : Ï„ (Bool â¤³ Bool â¤³ Bool);
// boolean disjunction.
rule or true true â†ª true
with or true false â†ª true
with or false true â†ª true
with or false false â†ª false;

// --- eo::not ---
sequential symbol not : Ï„ (Bool â¤³ Bool);
// boolean negation.
rule not true â†ª false
with not false â†ª true;

// --- eo::xor ---
sequential symbol xor : Ï„ (Bool â¤³ Bool â¤³ Bool);
// boolean xor.
rule xor true true â†ª false
with xor true false â†ª true
with xor false true â†ª true
with xor false false â†ª false;

// ---- arithmetic. ----
// `(add t1 t2)`:
// - If `t1` and `t2` are arithmetic values of the same category, then this
//   returns the addition of `t1` and `t2`.
// - If `t1` and `t2` are bitwise values of the same category and bitwidth,
//   this returns the binary value corresponding to their (unsigned) addition
//   modulo their bitwidth.
sequential symbol add [T1 T2] : Ï„ (T1 â¤³ T2 â¤³ (T1 âŠ T2));
rule add [<int>] [<int>] $i $j â†ª $i Int.+ $j
with add [<rat>] [<rat>] $x $y â†ª Rat.qadd $x $y;

// `(mul t1 t2)`:
// - If `t1` and `t2` are arithmetic values of the same category, then this
//   returns the multiplication of `t1` and `t2`.
// - If `t1` and `t2` are bitwise values of the same category and bitwidth,
//   this returns the binary value corresponding to their (unsigned)
//   multiplication modulo their bitwidth.
sequential symbol mul [T1 T2] : Ï„ (T1 â¤³ T2 â¤³ (T1 âŠ T2));
rule mul [<int>] [<int>] $i $j â†ª $i Int.* $j
with mul [<rat>] [<rat>] $x $y â†ª Rat.qmul $x $y;

// `(neg t1)`:
// - If `t1` is a arithmetic value, this returns the arithmetic negation of `t1`.
// - If `t1` is a binary value, this returns its (signed) arithmetic negation.
sequential symbol neg [T : Set]: Ï„ (T â¤³ T);
rule neg [<int>] $i â†ª Int.â€” $i;

// `(qdiv t1 t2)`: If `t1` and `t2` are values of the same category and `t2`
// is non-zero, then this returns the rational division of `t1` and `t2`.
sequential symbol qdiv [T1 T2]: Ï„ (T1 â¤³ T2 â¤³ <rat>);
rule qdiv [<int>] [<int>] $i $j â†ª qdiv (to_q $i) (to_q $j)
with qdiv [<rat>] [<rat>] $x $y â†ª qdiv $x $y;

// `(zdiv t1 t2)`:
// - If `t1` and `t2` are numeral values and `t2` is non-zero, then this
//   returns the integer division (floor) of `t1` and `t2`.
// - If `t1` and `t2` are bitwise values of the same category and bitwidth,
//   then this returns their (total, unsigned) division, where division by
//   zero returns the max unsigned value.
sequential symbol zdiv [T : Set]: Ï„ (T â¤³ T â¤³ T);
//rule zdiv [<int>] $i $j â†ª Int.zdiv $i $j
//with zdiv [<rat>] $x $y â†ª Int.zdiv (to_z $x) (to_z $y);

// `(zmod t1 t2)`:
// - If `t1` and `t2` are numeral values and `t2` is non-zero, then this
//   returns the integer remainder of `t1` and `t2`.
// - If `t1` and `t2` are bitwise values of the same category and bitwidth,
//   then this returns their (total, unsigned) remainder, where remainder by
//   zero returns `t1`.
sequential symbol zmod [T : Set]: Ï„ (T â¤³ T â¤³ T);
//rule zmod [<int>] $i $j â†ª Int.zmod $i $j;

// `(is_neg t1)`: If `t1` is an arithmetic value, this returns `true` if `t1`
// is strictly negative and `false` otherwise. Otherwise, this operator is not
// evaluated.
sequential symbol is_neg [T : Set]: Ï„ (T â¤³ Bool);
rule is_neg [<int>] $i â†ª Int.isZneg $i;

// `(gt t1 t2)`: Equivalent to `(is_neg (add (neg t1) t2))`.
sequential symbol gt [T1 : Set] [T2 : Set]: Ï„ (T1 â¤³ T2 â¤³ Bool);
rule gt [<int>] [<int>] $i $j â†ª isGt ($i Int.â‰ $j);


// ---- bitvectors. ----
// `(len t1)`:
// - Binary length (bitwidth) if `t1` is a binary value.
// - String length if `t1` is a string value.
sequential symbol len [T : Set]: Ï„ (T â¤³ <int>);

// `(concat t1 t2)`:
// - The concatenation of bits if `t1` and `t2` are binary values.
// - The concatenation of strings if `t1` and `t2` are string values.
sequential symbol concat [T : Set]: Ï„ (T â¤³ T â¤³ T);

// `(extract t1 t2 t3)`:
// - If `t1` is a binary value and `t2` and `t3` are numeral values, this
//   returns the binary value corresponding to the bits in `t1` from position
//   `t2` through `t3` if `0<=t2`, or the empty binary value otherwise.
// - If `t1` is a string value and `t2` and `t3` are numeral values, this
//   returns the string value corresponding to the characters in `t1` from
//   position `t2` through `t3` inclusive if `0<=t2`, or the empty string value
//   otherwise.
sequential symbol extract [T : Set]: Ï„ (T â¤³ <int> â¤³ <int> â¤³ T);

// `(find t1 t2)`: If `t1` and `t2` are string values, this returns a
// numeral value corresponding to the first index (left to right) where `t2`
// occurs as a substring of `t1`, or the numeral value `-1` otherwise.
sequential symbol find : Ï„ (<str> â¤³ <str> â¤³ <int>);


// ---- list operators. ----
// `(nil f T)`: If `f` is a right associative operator and `T` is a ground
// type, return its nil terminator. If `f` has a parametric nil terminator,
// return the terminator is specialized for `T`.
sequential symbol nil [T1 T2]
    (f : Ï„ (T1 â¤³ T2 â¤³ T2))
    (T : Ï„ Type) : Ï„ T;

// `(cons f t1 t2)`: If `t2` is an `f`-list, then this returns the term `(f t1 t2)`.
sequential symbol cons [U : Set] [T : Set] :
	Ï„ ((U â¤³ T â¤³ T) â¤³ U â¤³ T â¤³ T);
rule cons $f $x ($f â‹… $y â‹… $ys)
  â†ª $f $x ($f â‹… $y â‹… $ys)
with cons [_] [$T] $f $x $xs
  â†ª requires $xs (nil $f $T) ($f â‹… $x â‹… $xs);

sequential  symbol fold [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (L.list T1 â¤³ T2);
rule fold $f ($x L.â¸¬ $xs) â†ª $f â‹… $x â‹… (fold $f $xs)
with fold [_] [$T2] $f L.â–¡          â†ª nil $f $T2;

sequential symbol unfold [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ L.list T1);
rule unfold $f ($f â‹… $x â‹… $xs) â†ª $x L.â¸¬ (unfold $f $xs)
with unfold [_] [$T2] $f $z â†ª requires $z (nil $f $T2) L.â–¡;

// `(list_concat f t1 t2)`: If `t1` is an `f`-list with children
// `t11 ... t1n` and `t2` is an `f`-list with children `t21 ... t2m`, this
// returns `(f t11 ... t1n t21 ... t2m)` if `n+m>0` and `nil` otherwise.
// Otherwise, this operator does not evaluate.
sequential symbol list_concat
  [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) :
  Ï„ (T2 â¤³ T2 â¤³ T2);
rule list_concat $f $xs $ys â†ª fold $f (unfold $f $xs L.++ unfold $f $ys);



// `(list_len f t)`: If `t` is an `f`-list with children `t1 ... tn`, then
// this returns `n`.
symbol length [a] : L.ğ•ƒ a â†’ Int.â„¤;
sequential symbol list_len [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) :
  Ï„ (T2 â¤³ <int>);
rule list_len $f $xs â†ª length (unfold $f $xs);

// `(list_nth f t1 t2)`: If `t1` is `(f s0 ... s{n-1})` and `t2` is a numeral
// value such that `0<=t2<n`, then this returns `s_{t2}`. Otherwise, this
// operator does not evaluate.
symbol nth [a] : L.ğ•ƒ a â†’ Int.â„¤ â†’ Ï„ a;
sequential symbol list_nth [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ <int> â¤³ T1);
rule list_nth $f $xs $i â†ª nth (unfold $f $xs) $i;

// `(list_find f t1 t2)`: If `t1` is `(f s0 ... s{n-1})`, then this returns
// the smallest numeral value `i` such that `t2` is syntactically equal to
// `si`, or `-1` if no such `si` can be found. Otherwise, this operator does
// not evaluate.
symbol index [a] : Ï„ a â†’ L.ğ•ƒ a â†’ Int.â„¤;
rule index $x ($y L.â¸¬ $xs) â†ª ite (eq (index $x $xs)
with index $x L.â–¡ â†ª -1;

compute index 4 (0 L.â¸¬ 1 L.â¸¬ 2 L.â¸¬ L.â–¡);

sequential symbol list_find [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T1 â¤³ <int>);
rule list_find $f $t1 $t2 â†ª L.index (unfold $f $t1) $t2;

// `(list_rev f t1)`: If `t1` is an `f`-list with children `t11 ... t1n`,
// then this returns `(f t1n ... t11)`.
sequential symbol list_rev [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2);
// `(list_erase f t1 t2)`: If `t1` is an `f`-list, then this returns the
// result of removing the first occurrence of `t2` from `t1` if it exists.
// Returns `t1` unchanged if it does not contain `t2`.
sequential symbol list_erase [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T1 â¤³ T2);
// `(list_erase_all f t1 t2)`: If `t1` is an `f`-list, then this returns the
// result of removing all occurrences of `t2` from `t1`, where the remaining
// elements are kept in order. Returns `t1` unchanged if it does not
// contain `t2`.
sequential symbol list_erase_all [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T1 â¤³ T2);
// `(list_setof f t1)`: If `t1` is an `f`-list with children `t11 ... t1n`,
// this returns the `f`-list obtained by dropping each element from this list
// beyond the first occurrence. Note that the remaining elements are kept in
// order.
sequential symbol list_setof [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2);
// `(list_minclude f t1 t2)`: (Multiset inclusion) If `t1` is an `f`-list
// with children `t11 ... t1n` and `t2` is an `f`-list with children
// `t21 ... t2m`, then this returns true if each unique element in
// `t11 ... t1n` occurs with the greater than or equal multiplicity in
// `t21 ... t2m`. Note that order of the elements does not matter.
sequential symbol list_minclude [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2 â¤³ Bool);
// `(list_meq f t1 t2)`: (Multiset equal) Equivalent to
// `(and (list_minclude f t1 t2) (list_minclude f t2 t1))`.
sequential symbol list_meq [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2 â¤³ Bool);
// `(list_diff f t1 t2)`: (Difference) If `t1` is an `f`-list with children
// `t11 ... t1n` and `t2` is an `f`-list with children `t21 ... t2m`, this
// returns the result of erasing elements of `t11 ... t1n` that occur in
// `t21 ... t2m` where multiplicity is considered. In detail, for each
// `i = 1, ..., n`, if `t1i` occurs in `t21 ... t2m`, we remove one copy of
// it from that list. Otherwise if `t1i` does not occur in `t21 ... t2m`,
// we append it to the final result.
sequential symbol list_diff [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2 â¤³ T2);
// `(list_inter f t1 t2)`: (Intersection) If `t1` is an `f`-list with
// children `t11 ... t1n` and `t2` is an `f`-list with children
// `t21 ... t2m`, this returns the result of erasing elements of `t11 ... t1n`
// that do not occur in `t21 ... t2m` where multiplicity is considered. In
// detail, for each `i = 1, ..., n`, if `t1i` occurs in `t21 ... t2m`, we
// erase one copy of it from that list and append it to the final result.
sequential symbol list_inter [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2 â¤³ T2);
// `(list_singleton_elim f t1)`: (Singleton elimination) If `t1` is an
// `f`-list containing a single child `t11`, this returns `t11`. All other
// `f`-lists `t1` are returned unchanged. Otherwise, this operator does not
// evaluate.
sequential symbol list_singleton_elim [T1 T2] (f : Ï„ (T1 â¤³ T2 â¤³ T2)) : Ï„ (T2 â¤³ T2);

// eo::List, eo::List::cons, eo::List::nil
symbol List : Ï„ Type;
sequential symbol List__nil : Ï„ List; symbol âˆ â‰” List__nil;
sequential symbol List__cons [T : Set]: Ï„ (T â¤³ List â¤³ List);
