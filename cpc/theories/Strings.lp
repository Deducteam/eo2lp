require cpc.Prelude as eo;
require open cpc.theories.Builtin cpc.theories.Arith;
constant symbol Seq : τ (eo.Type ⤳ eo.Type);
constant symbol Char : Set;
symbol String : Set ≔ eo.<str>;
constant symbol RegLan : Set;
constant symbol seq_empty [T : Set]: τ (Seq T);
sequential symbol !seq_empty [T : Set]: τ (eo.Type ⤳d (λ (T : Set), T));
rule !seq_empty [$T] String ↪ ""
with !seq_empty [$T] (Seq $T) ↪ seq_empty;
constant symbol str_len [T : Set]: τ ((Seq T) ⤳ Int);
constant symbol str_++ [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Seq T);
constant symbol str_substr [T : Set]: τ ((Seq T) ⤳ Int ⤳ Int ⤳ Seq T);
constant symbol str_contains [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Bool);
constant symbol str_replace [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ (Seq T) ⤳ Seq T);
constant symbol str_indexof [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Int ⤳ Int);
constant symbol str_at [T : Set]: τ ((Seq T) ⤳ Int ⤳ Seq T);
constant symbol str_prefixof [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Bool);
constant symbol str_suffixof [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ Bool);
constant symbol str_rev [T : Set]: τ ((Seq T) ⤳ Seq T);
constant symbol str_update [T : Set]: τ ((Seq T) ⤳ Int ⤳ (Seq T) ⤳ Seq T);
constant symbol str_to_lower : τ (String ⤳ String);
constant symbol str_to_upper : τ (String ⤳ String);
constant symbol str_to_code : τ (String ⤳ Int);
constant symbol str_from_code : τ (Int ⤳ String);
constant symbol str_is_digit : τ (String ⤳ Bool);
constant symbol str_to_int : τ (String ⤳ Int);
constant symbol str_from_int : τ (Int ⤳ String);
constant symbol str_< : τ (String ⤳ String ⤳ Bool);
constant symbol str_<= : τ (String ⤳ String ⤳ Bool);
constant symbol str_replace_all [T : Set]: τ ((Seq T) ⤳ (Seq T) ⤳ (Seq T) ⤳ Seq T);
constant symbol str_replace_re : τ (String ⤳ RegLan ⤳ String ⤳ String);
constant symbol str_replace_re_all : τ (String ⤳ RegLan ⤳ String ⤳ String);
constant symbol str_indexof_re : τ (String ⤳ RegLan ⤳ Int ⤳ Int);
constant symbol re_allchar : τ RegLan;
constant symbol re_none : τ RegLan;
constant symbol re_all : τ RegLan;
constant symbol str_to_re : τ (String ⤳ RegLan);
symbol re_empty  ≔ str_to_re ⋅ "";
constant symbol re_* : τ (RegLan ⤳ RegLan);
constant symbol re_+ : τ (RegLan ⤳ RegLan);
constant symbol re_^ : τ (Int ⤳ RegLan ⤳ RegLan);
constant symbol re_opt : τ (RegLan ⤳ RegLan);
constant symbol re_comp : τ (RegLan ⤳ RegLan);
constant symbol re_range : τ (String ⤳ String ⤳ RegLan);
constant symbol re_++ : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re_inter : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re_union : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re_diff : τ (RegLan ⤳ RegLan ⤳ RegLan);
constant symbol re_loop : τ (Int ⤳ Int ⤳ RegLan ⤳ RegLan);
constant symbol str_in_re : τ (String ⤳ RegLan ⤳ Bool);
constant symbol seq_unit [T : Set]: τ (T ⤳ Seq T);
constant symbol seq_nth [T : Set]: τ ((Seq T) ⤳ Int ⤳ T);
constant symbol re_unfold_pos_component (s : τ String) (r : τ RegLan) (n : τ Int): τ String;
constant symbol strings_deq_diff [T : Set] (s : τ (Seq T)) (t : τ (Seq T)): τ Int;
constant symbol strings_stoi_result (s : τ String): τ (Int ⤳ Int);
constant symbol strings_stoi_non_digit (s : τ String): τ Int;
constant symbol strings_itos_result (n : τ Int): τ (Int ⤳ Int);
constant symbol strings_num_occur [T : Set] (s : τ (Seq T)) (t : τ (Seq T)): τ Int;
constant symbol strings_num_occur_re (e : τ String) (b : τ RegLan): τ Int;
constant symbol strings_occur_index [T : Set] (s : τ (Seq T)) (t : τ (Seq T)): τ (Int ⤳ Int);
constant symbol strings_occur_index_re (s : τ String) (r : τ RegLan): τ (Int ⤳ Int);
constant symbol strings_replace_all_result [T : Set] (t : τ (Seq T)): τ (Int ⤳ Seq T);
constant symbol witness_string_length (T : Set): τ (Int ⤳ Int ⤳ T);
