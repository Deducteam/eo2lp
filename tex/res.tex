\documentclass[class=llncs, crop=false]{standalone}

\input{preamble.tex}
\input{macros.tex}

\begin{document}
% ------------------------
Recall the definition of Eunoia terms and commands
given by \autoref{sec:eunoia}, and similarly those
of $\lambdapi$ from \autoref{sec:lambdapi}.
%
We define a \emph{translation} operator below,
which may act on the terms, types, and commands
of Eunoia.
%
First, we define an injection from Eunoia symbols
to those of $\lambdapi$.
%
\begin{definition}
For any $\eunoia$ symbol $s ‚àà ùíÆ_\eo$, define $\bar s$ thus:
$$
  \bar s =
\begin{cases}
  \esc s
  & \text{if $s$ contains any of
    $\{ \mtt{\$}, \mtt{@}, \ldots \}$,}
  \\
  {\ s}
  & \text{otherwise.}
\end{cases}
$$
\end{definition}
%
\begin{definition}
%
Let $\tm{‚ãÖ}$ be the least operator such that
$\tm{s} = \bar s$ and:
%
$$
\begin{array}[t]{r@{\ =\ }l}
  \tm{\eapp{s}{\vec t}}
  &
  \begin{cases}
    \tm{t_1} ‚§≥ \ldots ‚§≥ \ty{t_n}
    &
    \text{if $s = \prn{\mtt{->}}$,}
  \\
    \appldots{\bar s}{\tm{t_1}}{\tm{t_n}}
    &
    \text{otherwise.}
\end{cases}
\end{array}
$$
%
Furthermore, let $\ty{‚ãÖ}$ be the least operator
such that:
$$
\begin{array}[t]{r@{\ =\ }l}
  \ty{s} &
  \begin{cases}
    \Set & \text{if $s = \mtt{Type}$,}
  \\
    \El{\tm{s}} & \text{otherwise.}
  \end{cases}
\\[5mm]
  \ty{\eapp{s}{\vec t}}
  &
  \begin{cases}
    \ty{t_1} ‚Üí \ldots ‚Üí \ty{t_n}
    &
    \text{if $s = \prn{\mtt{->}}$,}
  \\
    \El{\tm{\eapp{s}{\vec t}}}
    &
    \text{otherwise.}
\end{cases}
\end{array}
$$
%
\end{definition}
%
Now, recall the abstract interface for $\eunoia$ commands
defined in \autoref{sec:eo-judge},
and also those of $\lambdapi$.
%
\begin{definition}
Let $\cmd{‚ãÖ}$ be the least operator such that
for any standard command $Œ¥$,
$\cmd Œ¥$ is a set of $\lambdapi$ commands satisfying
the following:
$$
\begin{array}[t]{c}
Œ¥ ‚ä¢ s(\vec œÅ) : t
{\quad{‚üπ}\quad}
\begin{cases}
\prn
{\mtt{symbol}\ {\bar s}\ {\ctx{\vec œÅ}} : {\ty{t}} ‚âî \tm{t'}}
‚àà \cmd{Œ¥} & \text{if $Œ¥ ‚ä¢ s(\vec œÅ) ‚âî t'$,}
\\
\prn{\mtt{symbol}\ {\bar s}\ {\ctx{\vec œÅ}} : {\ty{t}}}
‚àà \cmd{Œ¥}
& \text{otherwise.}
\end{cases}
\\[5mm]
\delta = \epar{\mtt{include}\ Œº}
{\quad{‚üπ}\quad}
\cmd{Œ¥} = \{\prn{\mtt{require}\ \mtt{open}\ {Œº}}\}
\end{array}
$$
%
The translation on proof commands $\cmd{\pi}$ is defined
similarly, where assumptions and steps are mapped to symbol declarations
in $\lambdapi$ that reflect their names, conclusions, and (if applicable)
rules, premises, and arguments, using the judgements $\pi ‚ä¢ s : \eapp{\mtt{Proof}}{œÜ}$
and $\pi ‚ä¢ s ‚âî \eapp{s'}{\plur t m\ \plur p n}$.
\end{definition}

We have implemented this translation as an OCaml program called
\texttt{eo2lp}, which uses the Menhir parser generator for parsing
Eunoia signatures and proof scripts. The tool reads Eunoia files,
elaborates them using the operator from \autoref{sec:eo-elab},
applies the translation operators defined above, and outputs
corresponding $\lambdapi$ code.


\subsubsection{Testing and Benchmarks.}
%
Because Eunoia is a complex and evolving system, we created a fork
of the CPC signature called CPC-MINI, which corresponds to the
fragment of CPC needed for formalizing the constants and inference
rules used in \cvc{5} proofs whose input problems are from the QF-UF
fragment of SMT-LIB. We translated all of CPC-MINI into $\lambdapi$
code, mirroring the directory tree of CPC-MINI.

For proof scripts, we used a small benchmark library (called `rodin')
of 30 unsatisfiable problems from the SMT-LIB benchmark suite,
restricted to the QF-UF fragment. We ran \cvc{5} on these problems
with the option \texttt{--proof-format=cpc} to dump their proofs in
Eunoia format. We then ran our \texttt{eo2lp} tool on these proof
scripts and obtained $\lambdapi$ files that typecheck successfully.

% \section{Conclusion and Future Work}\label{sec:conclu}

% \begin{definition}
% Let $\cmd{‚ãÖ}$ be the least operator such that:
% %
% $$
% \begin{array}[t]{l@{\ =\ }l}
% \cmd{\epar{\mtt{declare-const}\ s\ t\ \maybe{Œ±}}}
% & \mtt{symbol}\ {\bar s} : {\ty{t}};
% \\
% %-----------
% \cmd{\epar{\mtt{declare-parameterized-const}\ s\ \epar{\vec{œÅ}}\ t\ \maybe{Œ±}}}
% & \mtt{symbol}\ {\bar s}\ {\ctx{\vec œÅ}}: {\ty{t}};\
% \\
% %-----------
% \cmd{\epar{\mtt{define}\ {s}\ \epar{\vec œÅ} \ t\ \maybe{\mtt{:type}\ t'}}}
% & \mtt{symbol}\ {\bar s}\ {\ctx{\vec œÅ}} : {\ty{t'}}
%   ‚âî \tm{t};
% \\
% %-----------
% \cmd{
% \epar{\mtt{program}\ {s} \ \epar{\vec œÅ}\
% 			    \mtt{:signature}\,\epar{\vec{t}}\,t'
% 				\
% 			    \epar{\vec{r}}
% 			}
% }
% & \mtt{symbol}\ {\bar s}\ {\ctx{\vec œÅ}} : {\ty{\earr{\vec t\ t'}}};

% \end{array}
% $$
% $$
% \begin{array}[t]{c@{\ }l}
% 			    {‚¶Ç} &                                \\
% 			    {‚à£} &  \\
% 			    {‚à£} &    \\
% 			    {‚à£} &                                                                           \\
% 			    {‚à£} & {\color{MaterialGrey600}{\texttt{(}}}
% 			    \mtt{declare-rule}\ s\ \epar{\vec œÅ}\
% 			    \\ & \quad \maybe{\mtt{:premises}\ \epar{\vec{t}_{\text{prem}}}}\
% 			    \\ & \quad \maybe{\mtt{:args}\ \epar{\vec{t}_{\text{args}}}}\
% 			    \\ & \quad \maybe{\mtt{:requires}\ \epar{\vec{r}}}\
% 			    \\ & \quad \mtt{:conclusion}\ {t_{\text{conc}}}
% 			    {\color{MaterialGrey600}{\texttt{)}}}                                           \\
% 			    {‚à£} & \epar{\mtt{include}\ Œº}
% 		    \end{array}
% $$

\end{document}
